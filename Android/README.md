# Mobile_Pentest



### application journey

application journey from development to end user

**1. from the code to apk**

the default language for creating android applications is java or kotlin. additionally developers can write some code in c,c++. also the application contains xml files like androidMainfest.xml. along these files also there may be some resources such as scripts, images, audio, video, etc.

all these files are combined in a single zip file which is the final application package (apk). this apk file is signed with the developer certificate. the signed application is submitted to google play store and gets published once google decides that no malicious code or suspicious activity  in the application. finally users can download the application from play store.



the code is compiled into classes.dex file (Dalvik executable) and package it to apk file

### convert from apk to code

```
adb shell ps | grep -i app_name
adb shell pm list packages -f app_name
adb pull /path/to/apk_file
unzip app.apk -d dir_name 
```

till now we will have 

- AndroidMainfest.xml file
- META-INF directory that contains certificate information (cert_file_name.RSA)
- res directory
- kotlin directory
- classes.dex file where we have all the compiled java and kotlin classes



#### view the certificate

```
cd META-INF
keytool -printcert -file BNDLTOOL.RSA
```



### Reversing Android apps (static analysis)

#### 1. apktool

it shows a human readable version of the code known as `smali`. apktool gives us a smali representation of the Dalvik bytecode, we can modify the instructions and repackage the application and create a new version. but the smali syntax is not easy to understand. 

AndroidManifest.xml file generated in a readable format

so with apktool we can use it to modify the code but it is hard to analyze it.  

Analyze >> :no_entry:

Modify >> :white_check_mark:

```
apktool d app.apk
```





#### 2. JADx

go back to the original source code but it will be approximate representation of the original source code look like.

AndroidManifest.xml file generated in a binary format

so with JADx we can analyze the code becuase it gives us the original java or kotlin source code but we can not modify the source code.

Analyze >> :white_check_mark:

Modify >> :no_entry:





![](./assets/1.png)







### [AndroidManifest.xml](https://developer.android.com/guide/topics/manifest/manifest-intro)

The **AndroidManifest.xml file** *contains information of your package*, including components of the application such as activities, services, broadcast receivers, content providers etc.

- Supported screen sizes
- Supported SDK versions: minimum, target, and maximum
- Ability to send Push Notifications
- Various permissions for the application
- intent filters







### Patching android apps

when analyzing an application, a certain code in the application may stops or limits us from performing in depth analysis like preventing us from viewing the network traffic, root detection mechanisms. it is also used by the attackers to do things like bypass licenses, get access to the premium functions of the application, remove Advs or write backdoors.

we will make changes in the smali code and do modifications then generate the new apk file.

after modifying the smali code, we will generate the apk file 

``` 
delete META-INF directory

apktool b app_dir/ -o app_modified.apk
b >> build

adb install app_modified.apk
```



also in AndroidMainfest.xml make `android:testOnly="false" `

```
<application android:allowBackup="true" android:appComponentFactory="androidx.core.app.CoreComponentFactory" android:dataExtractionRules="@xml/data_extraction_rules" android:debuggable="true" android:extractNativeLibs="false" android:fullBackupContent="@xml/backup_rules" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:testOnly="false" android:theme="@style/Theme.Kotlin1">
```



you will get an error because the certificate is not valid. so you need to generate a new valid certificate

```
PS > adb install kotlin1modified.apk
Performing Streamed Install
adb: failed to install kotlin1modified.apk: Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from /data/app/vmdl632657351.tmp/base.apk: Attempt to get length of null array]
```





```
keytool.exe -genkey -v -keystore release.keystore -alias alias -keyalg RSA -keysize 2048 -validity 10000
```





```
jarsigner.exe -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore D:\tools\mobile\apps\kotlin1\kotlin1\release.keystore D:\tools\mobile\apps\kotlin1\kotlin1modified.apk alias

Enter Passphrase for keystore:
>>> Signer
    X.509, CN=kaim, OU=ITI, O=ITI, L=cairo, ST=cairo, C=eg
    Signature algorithm: SHA384withRSA, 2048-bit key
    [trusted certificate]

jar signed.

Warning:
The signer's certificate is self-signed.
The SHA1 algorithm specified for the -digestalg option is considered a security risk and is disabled.
The SHA1withRSA algorithm specified for the -sigalg option is considered a security risk and is disabled.
```





### [Android components](https://developer.android.com/guide/components/fundamentals)

There are four types of app components:

- Activities
- Services
- Broadcast receivers
- Content providers



#### Activity

screens of the application. the layout or view is called an activity. An *activity* is the entry point for interacting with the user. It represents a single screen with a user interface. 

An activity facilitates the following key interactions between system and app:

- Keeping track of what the user currently cares about—what is on-screen—so that the system keeps running the process that is hosting the activity.
- Knowing which previously used processes contain stopped activities the user might return to and prioritizing those processes more highly to keep them available.
- Helping the app handle having its process killed so the user can return to activities with their previous state restored.
- Providing a way for apps to implement user flows between each other, and for the system to coordinate these flows. The primary example of this is sharing.

- Layout defined in res/layout/*.xml
- one activity can launch another activity via intents 



Activity in java

```java
public class MainActivity extends Activity {
}
```



Activity in kotlin

```kotlin
class MainActivity : AppCompatActivity() {
}
```



#### Services

A *service* is a general-purpose entry point for keeping an app running in the background for all kinds of reasons. It is a component that runs in the background to perform long-running operations or to perform work for remote processes. A service does not provide a user interface.These components run at the backend, updating your data sources and Activities, triggering Notification, and also broadcast Intents. They also perform some tasks when applications are not active. A service can be used as a subclass of class Service: 



service in java

```java
public class ServiceName extends Service {
}
```



service in kotlin

```kotlin
class ServiceName : Service() {
}
```



#### Broadcast receivers

A broadcast receiver is a component that lets the system deliver events to the app outside of a regular user flow so the app can respond to system-wide broadcast announcements. Because broadcast receivers are another well-defined entry into the app, the system can deliver broadcasts even to apps that aren't currently running.

So, for example, an app can schedule an alarm to post a notification to tell the user about an upcoming event. Because the alarm is delivered to a `BroadcastReceiver` in the app, there is no need for the app to remain running until the alarm goes off.

Many broadcasts originate from the system, like a broadcast announcing that the screen is turned off, the battery is low, or a picture is captured. Apps can also initiate broadcasts, such as to let other apps know that some data is downloaded to the device and is available for them to use.

A broadcast receiver is implemented as a subclass of `BroadcastReceiver`, and each broadcast is delivered as an `Intent`

```
public class MyReceiver  extends  BroadcastReceiver {
   public void onReceive(context,intent){}
}
```



#### **Content providers**

A *content provider* manages a shared set of app data that you can store in the file system, in a SQLite database, on the web, or on any other persistent storage location that your app can access. Through the content provider, other apps can query or modify the data, if the content provider permits it.

A content provider component supplies data from one application to others on request. Such requests are handled by the methods of the *ContentResolver* class. The data may be stored in the file system, the database or somewhere else entirely.

A content provider is implemented as a subclass of **ContentProvider** class and must implement a standard set of APIs that enable other applications to perform transactions.

```java
public class MyContentProvider extends  ContentProvider {
   public void onCreate(){}
}
```



#### Declare components

The primary task of the manifest is to inform the system about the app's components. For example, a manifest file can declare an activity as follows:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:icon="@drawable/app_icon.png" ... >
        <activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... >
        </activity>
        ...
    </application>
</manifest>
```

In the `<application>` element, the `android:icon` attribute points to resources for an icon that identifies the app.

In the `<activity>` element, the `android:name` attribute specifies the fully qualified class name of the `Activity` subclass, and the `android:label` attribute specifies a string to use as the user-visible label for the activity.

You must declare all app components using the following elements:

- `<activity>` elements for activities
- `<service>` elements for services
- `<receiver>` elements for broadcast receivers
- `<provider>` elements for content providers

Activities, services, and content providers that you include in your source but don't declare in the manifest aren't visible to the system and, consequently, can never run. However, broadcast receivers can either be declared in the manifest or created dynamically in code as `BroadcastReceiver` objects and registered with the system by calling `registerReceiver()`.





### Intents

A messaging object that you can use to request an action from another application component. there are three kind of actions that intent can use for 

- startActivity()
- startService(), bindService()
- startBroadcast()

Intents in java

```java
public class Intent
extends Object implements Parcelable, Cloneable
```



Intents in kotlin

```kotlin
open class Intent : Parcelable, Cloneable
```



#### Intent Structure

- **action** -- The general action to be performed, such as `ACTION_VIEW`, `ACTION_EDIT`, `ACTION_MAIN`, etc.
- **data** -- The data to operate on, such as a person record in the contacts database, expressed as a `Uri`.
- **category** -- Gives additional information about the action to execute. For example, `CATEGORY_LAUNCHER` means it should appear in the Launcher as a top-level application, while `CATEGORY_ALTERNATIVE` means it should be included in a list of alternative actions the user can perform on a piece of data.
- **type** -- Specifies an explicit type (a MIME type) of the intent data. Normally the type is inferred from the data itself. By setting this attribute, you disable that evaluation and force an explicit type.

Some examples of action/data pairs are:

- `ACTION_VIEW` content://contacts/people/1 -- Display information about the person whose identifier is "1".

- `ACTION_EDIT` content://contacts/people/1 -- Edit information about the person whose identifier is "1".

  

#### [Intent Resolution](https://developer.android.com/reference/android/content/Intent#intent-resolution)

There are two primary forms of intents you will use.

- **Explicit Intents** have specified a component (via `setComponent(ComponentName)` or `setClass(Context, Class)`), which provides the exact class to be run. Often these will not include any other information, simply being a way for an application to launch various internal activities it has as the user interacts with the application.
- **Implicit Intents** have not specified a component; instead, they must include enough information for the system to determine which of the available components is best to run for that intent.





### Exploiting Activities

```
adb shell ps | grep app  # to get the package name
adb shell am start -n package_name/.activity_name
```



### Send Intent to the application

```
adb shell am start -n package_name/package_name.class_name --ei intent_extra extra_value
--ei extra integer
```



example

```
adb shell am start -n com.er.mo.apps.mypasswords/com.er.mo.apps.mypasswords.settings.AppearanceSettings --ei com.er.mo.apps.mypasswords.EXTRA_SUFCXNUQVRF 2
```





### [Fragments](https://developer.android.com/guide/fragments)

is the part of activity, it is also known as sub-activity. There can be  more than one fragment in an activity. Fragments represent multiple  screen inside one activity.

Android fragment lifecycle is affected by activity lifecycle because fragments are included in activity.

Each fragment has its own life cycle methods that is affected by activity life cycle because fragments are embedded in activity.

### Fragments injection









---

### Intent filter

- Implicit intent uses the intent filter to serve the user request.
- The intent filter specifies the types of intents that an activity, service, or broadcast receiver can respond.
- Intent filters are declared in the Android manifest file.
- Intent filter must contain `<action>`

**Examples of common action:**

- **ACTION_VIEW:** Use this action in intent  with startActivity() when you have some information that activity can  show to the user like showing an image in a gallery app or  an address  to view in a map app
- **ACTION_SEND:** You should use this in intent  with startActivity() when you have some data that the user can share  through another app, such as an email app or social sharing app.



### Broadcast receiver

Android BroadcastReceiver is a dormant component of android that listens to system-wide broadcast events or [intents](https://www.digitalocean.com/community/tutorials/android-studio-tutorial-hello-world-app). When any of these events occur it brings the application into action by either creating a status bar notification or performing a task. Unlike  activities, android `BroadcastReceiver` doesn’t contain any  user interface. Broadcast receiver is generally implemented to delegate  the tasks to services depending on the type of intent data that’s  received. Following are some of the important system wide generated  intents.



- System-wide events that happen on the device will be sent  >> `broadcast`

- Applications can listen to messages for the events >> `Intent-Filter`
- Act on the selected messgaes  >>  `Broadcast Receiver`

- Both System and apps can create a broadcast
- Types of broadcast: static, dynamic 





![](./assets/3.png)



In the androidMainfest.xml we have a `receiver` element, the receiver will be listing on the broadcast with `intent-filter`. in the `broadcast receiver` class we have `onReceiver()` element that will receiver a broadcast and then act on it. so when  a broadcast gets initiated, the SYSTEM checks for all the intent filters and if an application has an intent-filter that matches the broadcast  properties, the system passes the broadcast to the component. 







#### Static broadcast

![](./assets/4.png)





In the androidMainfest.xml we have a `receiver` element and `intent-filter` that will look for a broadcast. and will have a broadcast receiver class that has `onReceiver()` function.







#### Dynamic  broadcast

![](./assets/5.png)

you will not find anything in the androidMainfest.xml. instead, in one of the app classes you will find `rigisterRecever()` which will register a new broadcast receiver that will be valid only for the application life cycle and look for the pattern defined in the class. and you will have `onReceive()` function which will determine what action you need to perform when a broadcast is received





#### irccloud.apk

#### 1. With adb

```bash
adb shell am start -n com.irccloud.android/com.irccloud.android.activity.SAMLAuthActivity -e "title" "exploit-POC" -e "auth_url" "https://google.com"
```



#### 2. With android application

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContentView(R.layout.activity_main)

        // exploit SAML activity
        val intent = intent.setClassName("com.irccloud.android","com.irccloud.android.activity.SAMLAuthActivity");
        intent.putExtra("title","exploit-POC");
        intent.putExtra("auth_url","https://google.com");
        startActivity(intent);

        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }
    }
```



#### DynamicBR.apk

#### 2. With adb

```bash
adb shell am start -n edu.ksu.cs.dynamicbr/edu.ksu.cs.dynamicbr.EmailActivity -e "email" "karim@gmail.com" -e "text" "Exploit Dynamic Broadcast POC"
```





 #### 1. With android application

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContentView(R.layout.activity_main)
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }


        val intent = Intent("edu.ksu.cs.action.EMAIL")
        intent.putExtra("email", "karim@gmail.com");
        intent.putExtra("text", "I am pentester");
        sendBroadcast(intent);

    }
}
```













---

### Deep links

A Deep Link is a URL link that is generated, when anyone clicks on that link our app will be open with a specific activity or a screen. Using this URL we can send a message to our app with parameters. In WhatsApp, we can generate a deep link to send a message to a phone number with some message in it. Deep links are used to open your app’s specific screen with a URL link. 

- https://www.geeksforgeeks.org/deep-linking-in-android-with-example/
- https://developer.android.com/training/app-links/deep-linking
- https://medium.com/androiddevelopers/the-deep-links-crash-course-part-1-introduction-to-deep-links-2189e509e269



![](./assets/6.png)











---

### Data Storage

Data can be stored in three different ways: internal, external and remote

#### Internal Data storage

- uses internal storage 
- Type of data technique based on developer's preference and data type
- location: /data/data/package_name/

#### Types

- Shared preferences
- Databases
- Raw files 
- Keychain
- Cache



**Shared preferences**

- small key-value pairs 
- Examples: profile information, High score, configuration information, etc...
- developer may store sensitive information in cleartext 
- Location: /data/data/package_name/shared-prefs/
- Protected with UID (liunx based) or GID (permissions based) security



**Read from shared preferences**

```java
SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);
int defaultValue = getResources().getInteger(R.integer.saved_high_score_default_key);
int highScore = sharedPref.getInt(getString(R.string.saved_high_score_key), defaultValue);
```



**Write to shared preferences**

```java
SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);
SharedPreferences.Editor editor = sharedPref.edit();
editor.putInt(getString(R.string.saved_high_score_key), newHighScore);
editor.apply();
```







#### External Data storage

- any storage location outside device's on-board storage like SDcard or Virtual SDcard 
- Larger files: anything larger than configuration files or very small media/assets
- Lacation: /mnt/sdcard OR /storage   



#### Remote Data storage

Android applications can store data remotely like storing data in firebase

- https://medium.com/@sandeepkella23/exploring-data-storage-in-android-types-advantages-datastore-real-time-use-cases-and-best-8bb42fa6792e
- https://www.geeksforgeeks.org/shared-preferences-in-android-with-examples/

---

### Drozer

![](./assets/2.png)







```
drozer console connect --server ip_address

dz > permissions
```



list all installed applications

```
dz > run app.package.list
```



get info about package

```
dz > run app.package.info -a package_name
```



list all URIs in the app

```
dz > run scanner.provider.finduris -a package_name
```



get data from content provider

```
dz > run app.provider.query content://...
```



send broadcast action with extras

```
dz > run app.broadcast.send --action ACTION --extra string email user@gmail.com
```

**Note:** to run the broadcast the application must be open 







---

### cracking android pattern for the android apps

android apps like app lock

- [Android Pattern Lock Cracker](https://github.com/sch3m4/androidpatternlock)

- [APLBreaker](https://github.com/AleDiBen/APLBreaker)



### cracking android pattern/pin for the android device

the pattern is stored in gesture.key file

- [Android-PIN-Bruteforce](https://github.com/urbanadventurer/Android-PIN-Bruteforce)



---

### StrandHogg / Task hijacking

#### [Tasks and the back stack](https://developer.android.com/guide/components/activities/tasks-and-back-stack)

